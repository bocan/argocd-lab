keycloakx:
  # Use upstream multi-arch image (arm64 works)
  image:
    repository: quay.io/keycloak/keycloak
    tag: "26.3.3" # pick/lock your KC version
    pullPolicy: IfNotPresent

  replicas: 1
  resources: {} # add limits/requests later

  # Keycloak runtime flags / env
  extraEnv: |
    - name: KC_PROXY
      value: edge
    - name: KC_HOSTNAME
      value: keycloak.funderburg.uk
    - name: KC_METRICS_ENABLED
      value: "true"

  # External Postgres (recommended to avoid Bitnami deps)
  postgresql:
    enabled: false

  database:
    # Supply your own Service/Secret or external endpoint
    existingSecret: "external-database"
    existingSecretKey: "password"
    vendor: postgres
    host: postgres.postgres.svc.cluster.local
    port: 5432
    username: keycloak
    database: keycloak

  # TLS: let cert-manager handle it via Ingress
  ingress:
    enabled: true
    ingressClassName: traefik
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod
      external-dns.alpha.kubernetes.io/host: "keycloak.funderburg.uk"
    rules:
      hosts:
        - host: keycloak.funderburg.uk
          paths:
            - path: /
              pathType: Prefix
    tls:
      - hosts:
          - keycloak.funderburg.uk
        secretName: keycloak-cert

  # Metrics + ServiceMonitor (Prometheus Operator)
  metrics:
    enabled: true

  serviceMonitor:
    enabled: true
    endpoints:
      - port: http
        path: /metrics
        scheme: https
        tlsConfig:
          insecureSkipVerify: true
    labels:
      release: kube-prometheus-stack
    # prometheusRule:
    #   enabled: true
    #   groups: []    # you can port your alert rules later
